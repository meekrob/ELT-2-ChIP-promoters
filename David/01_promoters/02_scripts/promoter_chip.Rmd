---
title: "promoter_comparison"
params:
  stage: 'LE'
  rob.data: '../../../Rob/02_embryo_intestine_RNAseq/03_output/DE_Results_GFPplus-vs-GFPminus_apeglmShrink_220202.csv'
output:
  pdf_document: default
  html_document:
    df_print: paged
---
```{r input-files-params}
RNASEQ=params$rob.data

UPSTREAM=1000
DOWNSTREAM=200
IDR_BED = sprintf("../01_input/ELT2_%s_combined_IDR.bed", params$stage) # peaks input file
OUTPUT_03 = normalizePath("../03_output") 

# output files from genomic ranges
PROMOTOR_BED_PATH = sprintf("%s/filtered.promoters.minus%d_plus%d.bed", 
                            OUTPUT_03, 
                            UPSTREAM, 
                            DOWNSTREAM)
# colliding promoters removed
NR_PROMOTOR_BED_PATH = sprintf("%s/nr.promoters.minus%d_plus%d.bed",
                               OUTPUT_03, 
                               UPSTREAM, 
                               DOWNSTREAM)

# input signal file for wiggle tool step
SIGNAL_BW = sprintf("../01_input/ELT2_%s_combined_subtracted.bw", params$stage)
# input signal file for deeptools (e.g. ELT2_L1_combined_subtracted.interp.bw)
INTERP_SIGNAL_BW = sprintf("../01_input/ELT2_%s_combined_subtracted.interp.bw", params$stage)

# output files from wiggle tool step
PROMOTOR_DF_PATH = sprintf("%s/filtered.promoters.minus%d_plus%d.df", 
                           OUTPUT_03, 
                           UPSTREAM, 
                           DOWNSTREAM)

NR_PROMOTOR_DF_PATH = sprintf("%s/nr.promoters.minus%d_plus%d.df", 
                           OUTPUT_03, 
                           UPSTREAM, 
                           DOWNSTREAM)

IDR_DF = sprintf("../01_input/ELT2_%s_combined_IDR.df", params$stage) # peaks with signal agg

#################



```

```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#install.packages("devtools")
#devtools::install_github("meekrob/ParasiteXML") # Brings biomaRt, GenomicRanges
library(ParasiteXML)
library(biomaRt)
library(GenomicRanges)
library(ggplot2)
library(tidyr)
```

## Promoters are upstream regions of all protein-coding genes

```{r get-promoters,warning=FALSE,message=FALSE}
library(biomaRt)
mart = getParamart()

promoters = getCElegansPromoters(mart, upstream = UPSTREAM, downstream = DOWNSTREAM) 
promoters = trim(sort(promoters, ignore.strand=T)) # trim because one interval is chrIV:-359-840 at -1000/+200
head(promoters)
```

```{r filter-collisions}
selfOverlaps = findOverlaps(promoters, ignore.strand=T)
#head(selfOverlaps)

# selfOverlaps includes everything against itself + overlaps between promoters
# Filter out the self hits, and retain the "between" hits as "collisions".
collisions = selfOverlaps[!isSelfHit(selfOverlaps)]

overlappingPromoterRows = unique(c( from(collisions), to(collisions)))
length(overlappingPromoterRows)
sprintf("There are %d overlaps between %d promoters.", length(collisions), length(overlappingPromoterRows))

filtered.promoters = promoters[-which(seqnames(promoters) == 'chrM')]

# to remove overlapping promoters, uncomment below
nr.promoters = filtered.promoters[-overlappingPromoterRows]
sprintf("There are %d unambiguous promoters.", length(nr.promoters))

# -500,+200
# "There are 4256 overlaps between 4067 promoters."
# "There are 15922 unambiguous promoters."

# -1000,+200
#"There are 8008 overlaps between 6749 promoters."
#"There are 13246 unambiguous promoters."

write.table(filtered.promoters, PROMOTOR_BED_PATH, sep="\t", quote=F, row.names=F, col.names=F)
write.table(nr.promoters, NR_PROMOTOR_BED_PATH, sep="\t", quote=F, row.names=F, col.names=F)
```

# Setup a conda environment in your shell
Install a conda environment containing wiggletools and ucsc user apps via 
`root/David/01_promoters/02_scripts/conda_envs/elt-2-rev.yaml`


To pass variable names to the *bash* chunk by setting them in the environment with `Sys.setenv`.
```{r set-up-bash}

Sys.setenv(PROMOTOR_BED_PATH=PROMOTOR_BED_PATH, # all promoters
           NR_PROMOTOR_BED_PATH = NR_PROMOTOR_BED_PATH, # overlapping removed
           IDR_BED = IDR_BED, 
           IDR_DF = IDR_DF, 
           SIGNAL_BW = SIGNAL_BW,
           PROMOTOR_DF_PATH = PROMOTOR_DF_PATH,
           NR_PROMOTOR_DF_PATH = NR_PROMOTOR_DF_PATH,
           STAGE=params$stage
           )
```

Run wiggletools in a bash session.
```{bash run-wiggle-tools}
source $HOME/.bash_profile
conda activate elt-2-rev

set -ue # exit 1 if any vars are not set (using Sys.setenv above)
echo PROMOTOR_BED_PATH $PROMOTOR_BED_PATH
echo NR_PROMOTOR_BED_PATH $NR_PROMOTOR_BED_PATH
echo NR_PROMOTOR_DF_PATH $NR_PROMOTOR_DF_PATH
echo IDR_BED $IDR_BED
echo IDR_DF $IDR_DF
echo SIGNAL_BW $SIGNAL_BW
echo STAGE $STAGE

#wiggletools
wiggletools apply_paste - meanI maxI $PROMOTOR_BED_PATH $SIGNAL_BW > $PROMOTOR_DF_PATH
echo $PROMOTOR_DF_PATH
head -5 $PROMOTOR_DF_PATH

wiggletools apply_paste - meanI maxI $NR_PROMOTOR_BED_PATH $SIGNAL_BW > $NR_PROMOTOR_DF_PATH
echo $NR_PROMOTOR_DF_PATH
head -5 $NR_PROMOTOR_DF_PATH

wiggletools apply_paste - meanI maxI $IDR_BED $SIGNAL_BW > $IDR_DF
echo $IDR_DF
head -5 $IDR_DF
```

Read in the results of the wiggletools commands.
```{r read-calculated-data, warning=FALSE}

promoters.agg = read.table(PROMOTOR_DF_PATH)
colnames(promoters.agg) <- c("chrom", "start","end","len", "strand", "wbps_gene_id", "gene_name", "chip_signal_mean", "chip_signal_max")

IDR_peaks.agg = read.table(IDR_DF)

IDR_peaks.agg$V4 = NULL
IDR_peaks.agg$V5 = NULL
IDR_peaks.agg$V6 = NULL
IDR_peaks.agg$V8 = NULL
colnames(IDR_peaks.agg) <- c("chrom", "start","end","intensity","nlogq","offset","signal.mean","signal.max")

gr.IDR = makeGRangesFromDataFrame(IDR_peaks.agg,keep.extra.columns = T)
seqinfo(gr.IDR) <- Seqinfo(genome="ce11")

gr.promoters = makeGRangesFromDataFrame(promoters.agg,keep.extra.columns = T)
seqinfo(gr.promoters) <- Seqinfo(genome="ce11")
```

Attach log scale promoter signal values.
```{r promoter-signal-values, warning=FALSE}
chipmean.minval = min(gr.promoters$chip_signal_mean,na.rm=T)
chipmean.minval
chipmax.minval = min(gr.promoters$chip_signal_max,na.rm=T)
chipmax.minval
chipmean.log = log(-chipmean.minval + 1 + gr.promoters$chip_signal_mean,base=2)
chipmax.log = log(-chipmax.minval + 1 + gr.promoters$chip_signal_max,base=2)

gr.promoters$log_chip_signal_mean = chipmean.log
gr.promoters$log_chip_signal_max = chipmax.log
head(gr.promoters)

# output file
LOG_PROMOTOR_DF_PATH = sprintf("%s/log_filtered.promoters.minus%d_plus%d.df", OUTPUT_03, UPSTREAM, DOWNSTREAM)
write.table(as.data.frame(gr.promoters), file = LOG_PROMOTOR_DF_PATH,quote=F, row.names=F,sep="\t")
```

Find overlaps between promoters and IDR peaks. Populate IDR signal fields when a peak exists, leave NaN otherwise.
```{r merge-promoters-peaks}
laps = findOverlaps(gr.promoters,gr.IDR, ignore.strand=T,minoverlap = 100)

head(laps)

gr.promoters$IDR_mean = NaN
gr.promoters$IDR_max = NaN
gr.promoters$IDR_value = NaN
gr.promoters$nlogq = NaN
gr.promoters[from(laps)]$IDR_max = gr.IDR[to(laps)]$signal.max
gr.promoters[from(laps)]$IDR_mean = gr.IDR[to(laps)]$signal.mean
gr.promoters[from(laps)]$IDR_value = gr.IDR[to(laps)]$intensity
gr.promoters[from(laps)]$nlogq = gr.IDR[to(laps)]$nlogq
print("Number of promoters overlapping an IDR peak:")
sum(!is.nan(gr.promoters$IDR_max))

```

```{r IDR-score-values}

idr.nonlog = gather(as.data.frame(gr.promoters)[,c('IDR_value','IDR_mean','IDR_max')], key="dataset")
ggplot(idr.nonlog, aes(x=value, fill=dataset))  + geom_density(alpha=.5) + labs(title="Distributions of log10 transformed IDR NON-Log transformed values")

idr.val.ecdf = ecdf(gr.promoters$IDR_value)
idr.mean.ecdf = ecdf(gr.promoters$IDR_mean)
idr.max.ecdf = ecdf(gr.promoters$IDR_max)

plot(idr.val.ecdf)
lines(idr.mean.ecdf,col="blue")
lines(idr.max.ecdf,col="red")

# the data currently have all positive values, so no adjustment made for log
idr.val.log = log10(gr.promoters$IDR_value)
idr.mean.log = log10(gr.promoters$IDR_mean)
idr.max.log = log10(gr.promoters$IDR_max)

idr.val.log.ecdf = ecdf(idr.val.log)
idr.mean.log.ecdf = ecdf(idr.mean.log) 
idr.max.log.ecdf = ecdf(idr.max.log)

plot(idr.val.log.ecdf)
lines(idr.mean.log.ecdf,col="blue")
lines(idr.max.log.ecdf,col="red")

log.vals = data.frame(idr.mean = idr.mean.log, idr.val = idr.val.log, idr.max = idr.max.log)

long.log.vals = gather(log.vals, key="dataset")
head(long.log.vals)
ggplot(long.log.vals, aes(x=value, fill=dataset))  + geom_density(alpha=.5) + labs(title="Distributions of log10 transformed IDR values")

gr.promoters$IDR_logTEN_max = idr.max.log
gr.promoters$IDR_logTEN_mean = idr.mean.log
gr.promoters$IDR_logTEN_value = idr.val.log
sum(idr.mean.log > 2.5, na.rm=T)
```

Read in RNA-seq data, join promoters by wbps geneid, and then sort logFoldChange high to low.
```{r rob-combine}
# input file
rnaseq = read.csv(RNASEQ)
rownames(rnaseq) <- rnaseq$WBGeneID

mcols(gr.promoters) <- mcols(gr.promoters) %>% 
  cbind(rnaseq[gr.promoters$wbps_gene_id,2:6])  %>% 
  as.data.frame() %>% 
  dplyr::rename(IDR_nlogq = nlogq)

names(gr.promoters) <- gr.promoters$wbps_gene_id

# sort promoters high to low by log2FC
gr.promoters = gr.promoters[order(gr.promoters$log2FoldChange,decreasing=T)]

head(gr.promoters)
```

```{r rnaseq-pvalue-na}
# look at the number filtered by DESeq2
# as described by https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#pvaluesNA
baseMean_is_zero = rnaseq$baseMean == 0
pval_na = is.na(rnaseq$pvalue)
padj_na = is.na(rnaseq$padj)
# case one
sum(baseMean_is_zero & pval_na & padj_na)

# case two
sum(!baseMean_is_zero & pval_na & padj_na)

# case three
sum(!pval_na & padj_na)
```

```{r make-classes-ABCD}
# divide groups by peak and padj
enriched_intestine = gr.promoters$padj<.05 & !is.na(gr.promoters$padj) & gr.promoters$log2FoldChange > 0
has_peak = !is.nan(gr.promoters$IDR_max)
classA = enriched_intestine & has_peak
classB = !enriched_intestine & has_peak
classC = enriched_intestine & !has_peak
classD = !enriched_intestine & !has_peak

m = matrix( c(sum(classA),
            sum(classB),
            sum(classC),
            sum(classD)), ncol = 2)
m.chisq = chisq.test(m)

gr.promoters$class = "classA"
gr.promoters$class[classB] <- "classB"
gr.promoters$class[classC] <- "classC"
gr.promoters$class[classD] <- "classD"
```

```{r make-classes-hilo}
promoters.hilo = as.data.frame(gr.promoters)

# BED format
write.table(promoters.hilo, file.path(OUTPUT_03, "promoters.hilo.bed"), quote=F, sep="\t", row.names=F, col.names=F)

# Matrix format readable into R
write.table(promoters.hilo, file.path(OUTPUT_03, "promoters.hilo.tsv"), quote=F, sep="\t", row.names=T, col.names=T)


PROMOTERS_HILO_BED_PATH = file.path(OUTPUT_03, "promoters.hilo.bed")
PROMOTERS_HILO_BED_PATH_A = file.path(OUTPUT_03, "promoters.hilo.classA.bed")
PROMOTERS_HILO_BED_PATH_B = file.path(OUTPUT_03, "promoters.hilo.classB.bed")
PROMOTERS_HILO_BED_PATH_C = file.path(OUTPUT_03, "promoters.hilo.classC.bed")
PROMOTERS_HILO_BED_PATH_D = file.path(OUTPUT_03, "promoters.hilo.classD.bed")


write.table(promoters.hilo[classA,], 
            PROMOTERS_HILO_BED_PATH_A, quote=F, sep="\t", row.names=F, col.names=F)
write.table(promoters.hilo[classB,], 
            PROMOTERS_HILO_BED_PATH_B, quote=F, sep="\t", 
row.names=F, col.names=F)
write.table(promoters.hilo[classC,], 
            PROMOTERS_HILO_BED_PATH_C, quote=F, sep="\t", 
row.names=F, col.names=F)
write.table(promoters.hilo[classD,], 
            PROMOTERS_HILO_BED_PATH_D, quote=F, sep="\t", 
row.names=F, col.names=F)

#### deeptooling up versus down only, no other filters
promoters.hilo.up = promoters.hilo %>% filter(log2FoldChange > 0)
promoters.hilo.down = promoters.hilo %>% filter(log2FoldChange < 0)

PROMOTERS_HILO_BED_PATH_UP = file.path(OUTPUT_03, "promoters.hilo.up.bed")
PROMOTERS_HILO_BED_PATH_DOWN = file.path(OUTPUT_03, "promoters.hilo.down.bed")


write.table(promoters.hilo.up, 
            PROMOTERS_HILO_BED_PATH_UP, 
            quote=F, 
            sep="\t", 
row.names=F, col.names=F)

write.table(promoters.hilo.down, 
            PROMOTERS_HILO_BED_PATH_DOWN, 
            quote=F, 
            sep="\t", 
row.names=F, col.names=F)

```

To produce the deeptools output, execute DEEPTOOLS.bash.

It will compute promoters.hilo.mx and promoters.hilo.pdf.

Deeptools PDFs indicate a font called dejavu, if you're tired of replacing it in Illustrator, install it from: https://sourceforge.net/projects/dejavu/

```{r set-deeptools-shell-vars}

Sys.setenv(UPSTREAM=UPSTREAM,
           DOWNSTREAM=DOWNSTREAM,
           INTERP_SIGNAL_BW=INTERP_SIGNAL_BW,
            PROMOTERS_HILO_BED_PATH=PROMOTERS_HILO_BED_PATH,
            PROMOTERS_HILO_BED_PATH_A=PROMOTERS_HILO_BED_PATH_A,
            PROMOTERS_HILO_BED_PATH_B=PROMOTERS_HILO_BED_PATH_B,
            PROMOTERS_HILO_BED_PATH_C=PROMOTERS_HILO_BED_PATH_C,
            PROMOTERS_HILO_BED_PATH_D=PROMOTERS_HILO_BED_PATH_D,
            PROMOTERS_HILO_BED_PATH_UP=PROMOTERS_HILO_BED_PATH_UP,
            PROMOTERS_HILO_BED_PATH_DOWN=PROMOTERS_HILO_BED_PATH_DOWN)
```


```{bash deeptools-ABCD}
source $HOME/.bash_profile
conda activate derptools # yaml environ in 02_scripts/conda_envs

set -ue # exit 1 if any vars are not set (using Sys.setenv in prev chunks)
BODYLENGTH=$(($UPSTREAM + $DOWNSTREAM))

# real	1m59.354s
# user	3m47.980s
# sys	0m2.663s
time computeMatrix scale-regions --regionBodyLength $BODYLENGTH \
                                --startLabel 'up-1Kb' \
                                --endLabel down+200 \
                                --beforeRegionStartLength $UPSTREAM\
                                --afterRegionStartLength $DOWNSTREAM\
                                -R $PROMOTERS_HILO_BED_PATH_A $PROMOTERS_HILO_BED_PATH_B $PROMOTERS_HILO_BED_PATH_C $PROMOTERS_HILO_BED_PATH_D\
                                -S $INTERP_SIGNAL_BW\
                                -p 4 -o promoters.olap100.hilo.mx

plotHeatmap  --matrixFile promoters.olap100.hilo.mx\
             -out promoters.olap100.hilo.pdf\
             --sortRegions no\
             --colorMap RdYlBu_r\
             --startLabel '' --endLabel ''\
             --regionsLabel 'peak+int. enrich.' 'peak+ NOT int. enrich.' 'NO peak + int. enrich.' 'NO peak + NOT int. enrich.'\
             --samplesLabel 'ELT-2 signal (reps. combined subtracted)'
```

```{bash deeptools-hilo}
source $HOME/.bash_profile
conda activate derptools # yaml environ in 02_scripts/conda_envs
BODYLENGTH=$(($UPSTREAM + $DOWNSTREAM))
set -ue # exit 1 if any vars are not set (using Sys.setenv in prev chunks)
time computeMatrix scale-regions --regionBodyLength $BODYLENGTH \
                            --startLabel 'up-1Kb' \
                            --endLabel down+200 \
                            --beforeRegionStartLength $UPSTREAM\
                            --afterRegionStartLength $DOWNSTREAM\
                            -R $PROMOTERS_HILO_BED_PATH_UP $PROMOTERS_HILO_BED_PATH_DOWN\
                            -S $INTERP_SIGNAL_BW\
                            -p 4 -o promoters.hilo.updown.mx

plotHeatmap  --matrixFile promoters.hilo.updown.mx\
             -out promoters.updown.pdf\
             --sortRegions no\
             --colorMap RdYlBu_r\
             --startLabel '' --endLabel ''\
             --regionsLabel 'log2FC > 0' 'log2FC < 0'\
             --samplesLabel 'ELT-2 signal (reps. combined subtracted)'
```


```{r gene-centric-to-appease-derptools, echo = FALSE, eval = FALSE}
# this code chunk is deactivated because the promoter-only visualization is better
classA.genes = promoters.hilo[classA]$wbps_gene_id
classB.genes = promoters.hilo[classB]$wbps_gene_id
classC.genes = promoters.hilo[classC]$wbps_gene_id
classD.genes = promoters.hilo[classD]$wbps_gene_id
genes = getCElegansGeneLocs(mart, gene_list=NULL, WBID=c(classA.genes,classB.genes,classC.genes,classD.genes))

names(genes) = genes$wbps_gene_id
gr.classA.genes = genes[classA.genes]
gr.classB.genes = genes[classB.genes]
gr.classC.genes = genes[classC.genes]
gr.classD.genes = genes[classD.genes]


write.table(as.data.frame(gr.classA.genes), 
            file.path(OUTPUT_03, "genes.classA.bed"), quote=F, sep="\t", row.names=F, col.names=F)
write.table(as.data.frame(gr.classB.genes), 
            file.path(OUTPUT_03, "genes.classB.bed"), quote=F, sep="\t", 
row.names=F, col.names=F)
write.table(as.data.frame(gr.classC.genes), 
            file.path(OUTPUT_03, "genes.classC.bed"), quote=F, sep="\t", 
row.names=F, col.names=F)
write.table(as.data.frame(gr.classD.genes), 
            file.path(OUTPUT_03, "genes.classD.bed"), quote=F, sep="\t", 
row.names=F, col.names=F)
```

```{r signal-vs-expression plots}
gr.promoters.classA = gr.promoters[classA]

# scatter plot with linear mods on logFC up and down separately
gr.promoters.classA %>% as.data.frame() %>% 
  ggplot(
    aes(x=log_chip_signal_max, 
        y=log2FoldChange,
        group=log2FoldChange>0)) + geom_point() +
        geom_smooth(method='lm', formula= y~x) +
        ggtitle("Peak + Intestine Enriched") 

classA.up = promoters.hilo %>% as.data.frame() %>% filter(classA & log2FoldChange > 0)
up.table = classA.up[,c('log2FoldChange',
                      'chip_signal_mean',
                      'chip_signal_max',
                      'log_chip_signal_mean', 
                      'log_chip_signal_max',  
                      'IDR_mean',   'IDR_max', 'IDR_value')]

cor.up.table = cor(up.table)
options(digits=3)
knitr::kable(cor.up.table, caption="Pairwise correlations")
```

```{r cor.tests}
cor.test(classA.up[,'log2FoldChange'],classA.up[,'IDR_mean'])
cor.test(classA.up[,'log2FoldChange'],classA.up[,'log_chip_signal_mean'])
```

```{r set-vars-for-shell}
Sys.setenv(PROMOTOR_BED_PATH=PROMOTOR_BED_PATH,
           NR_PROMOTOR_BED_PATH=NR_PROMOTOR_BED_PATH)
```

```{bash }
source $HOME/.bash_profile
conda activate elt-2-rev
wiggletools

```