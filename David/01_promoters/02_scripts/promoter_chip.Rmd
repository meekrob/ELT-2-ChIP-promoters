---
title: "promoter_comparison"
output:
  pdf_document: default
  html_document:
    df_print: paged
---

```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#install.packages("devtools")
#devtools::install_github("meekrob/ParasiteXML") # Brings biomaRt, GenomicRanges
library(ParasiteXML)
library(biomaRt)
library(GenomicRanges)
library(ggplot2)
library(tidyr)
```

## Promoters are upstream regions of all protein-coding genes

```{r get-promoters,warning=FALSE,message=FALSE}
library(biomaRt)
mart = getParamart()
UPSTREAM=1000
DOWNSTREAM=200
promoters = getCElegansPromoters(mart, upstream = UPSTREAM, downstream = DOWNSTREAM) 
promoters = trim(sort(promoters, ignore.strand=T)) # trim because one interval is chrIV:-359-840 at -1000/+200
head(promoters)
selfOverlaps = findOverlaps(promoters, ignore.strand=T)
#head(selfOverlaps)

# selfOverlaps includes everything against itself + overlaps between promoters
# Filter out the self hits, and retain the "between" hits as "collisions".
collisions = selfOverlaps[!isSelfHit(selfOverlaps)]

overlappingPromoterRows = unique(c( from(collisions), to(collisions)))
length(overlappingPromoterRows)
sprintf("There are %d overlaps between %d promoters.", length(collisions), length(overlappingPromoterRows))
filtered.promoters = promoters[-overlappingPromoterRows]
filtered.promoters = filtered.promoters[-which(seqnames(filtered.promoters) == 'chrM')]
sprintf("There are %d unambiguous promoters.", length(filtered.promoters))

# -500,+200
# "There are 4256 overlaps between 4067 promoters."
# "There are 15922 unambiguous promoters."

# -1000,+200
#"There are 8008 overlaps between 6749 promoters."
#"There are 13246 unambiguous promoters."

```

```{r write-promoters-bed}
OUTPUT_03 = normalizePath("../03_output") 
PROMOTOR_BED_PATH = sprintf("%s/filtered.promoters.minus%d_plus%d.bed", OUTPUT_03, UPSTREAM, DOWNSTREAM)
write.table(filtered.promoters, PROMOTOR_BED_PATH, sep="\t", quote=F, row.names=F, col.names=F)
```

# Setup a conda environment in your shell
I had to call my local setup script .zshrc, where I have initialized conda,
to have access to the "base" environment, where I have installed wiggletools and ucsc user apps.

`$ wiggletools apply_paste filtered.promoters.minus1000_plus200.df meanI maxI filtered.promoters.minus1000_plus200.bed ELT2_LE_combined_subtracted.bw`

The same can be done for the IDR peaks.

`$ wiggletools apply_paste LE_IDR_peaks.df meanI maxI ELT2_LE_combined.IDR.bed ELT2_LE_combined_subtracted.bw`
```{r read-data, warning=FALSE}
PROMOTOR_DF_PATH = sprintf("%s/filtered.promoters.minus%d_plus%d.df", OUTPUT_03, UPSTREAM, DOWNSTREAM)
promoters.agg = read.table(PROMOTOR_DF_PATH)
colnames(promoters.agg) <- c("chrom", "start","end","len", "strand", "wbps_gene_id", "gene_name", "chip_signal_mean", "chip_signal_max")

IDR_peaks.agg = read.table(file.path(OUTPUT_03,"LE_IDR_peaks.df"))
IDR_peaks.agg$V4 = NULL
IDR_peaks.agg$V5 = NULL
IDR_peaks.agg$V6 = NULL
IDR_peaks.agg$V8 = NULL
colnames(IDR_peaks.agg) <- c("chrom", "start","end","intensity","nlogq","offset","signal.mean","signal.max")

gr.IDR = makeGRangesFromDataFrame(IDR_peaks.agg,keep.extra.columns = T)
seqinfo(gr.IDR) <- Seqinfo(genome="ce11")

gr.promoters = makeGRangesFromDataFrame(promoters.agg,keep.extra.columns = T)
seqinfo(gr.promoters) <- Seqinfo(genome="ce11")
```

```{r promoter-signal-values, warning=FALSE}
chipmean.minval = min(gr.promoters$chip_signal_mean,na.rm=T)
chipmean.minval
chipmax.minval = min(gr.promoters$chip_signal_max,na.rm=T)
chipmax.minval
chipmean.log = log(-chipmean.minval + 1 + gr.promoters$chip_signal_mean,base=2)
chipmax.log = log(-chipmax.minval + 1 + gr.promoters$chip_signal_max,base=2)

gr.promoters$log_chip_signal_mean = chipmean.log
gr.promoters$log_chip_signal_max = chipmax.log
head(gr.promoters)

LOG_PROMOTOR_DF_PATH = sprintf("%s/log_filtered.promoters.minus%d_plus%d.df", OUTPUT_03, UPSTREAM, DOWNSTREAM)
write.table(as.data.frame(gr.promoters), file = LOG_PROMOTOR_DF_PATH,quote=F, row.names=F,sep="\t")
```

```{r merge-promoters-peaks}
laps = findOverlaps(gr.promoters,gr.IDR, ignore.strand=T,minoverlap = 100)
length(laps)
head(laps)

gr.promoters$IDR_mean = NaN
gr.promoters$IDR_max = NaN
gr.promoters$IDR_value = NaN
gr.promoters$nlogq = NaN
gr.promoters[from(laps)]$IDR_max = gr.IDR[to(laps)]$signal.max
gr.promoters[from(laps)]$IDR_mean = gr.IDR[to(laps)]$signal.mean
gr.promoters[from(laps)]$IDR_value = gr.IDR[to(laps)]$intensity
gr.promoters[from(laps)]$nlogq = gr.IDR[to(laps)]$nlogq
print("Number of promoters overlapping an IDR peak:")
sum(!is.nan(gr.promoters$IDR_max))

```

```{r IDR-score-values}

idr.nonlog = gather(as.data.frame(gr.promoters)[,c('IDR_value','IDR_mean','IDR_max')], key="dataset")
ggplot(idr.nonlog, aes(x=value, fill=dataset))  + geom_density(alpha=.5) + labs(title="Distributions of log10 transformed IDR NON-Log transformed values")

idr.val.ecdf = ecdf(gr.promoters$IDR_value)
idr.mean.ecdf = ecdf(gr.promoters$IDR_mean)
idr.max.ecdf = ecdf(gr.promoters$IDR_max)

plot(idr.val.ecdf)
lines(idr.mean.ecdf,col="blue")
lines(idr.max.ecdf,col="red")

# the data currently have all positive values, so no adjustment made for log
idr.val.log = log10(gr.promoters$IDR_value)
idr.mean.log = log10(gr.promoters$IDR_mean)
idr.max.log = log10(gr.promoters$IDR_max)

idr.val.log.ecdf = ecdf(idr.val.log)
idr.mean.log.ecdf = ecdf(idr.mean.log) 
idr.max.log.ecdf = ecdf(idr.max.log)

plot(idr.val.log.ecdf)
lines(idr.mean.log.ecdf,col="blue")
lines(idr.max.log.ecdf,col="red")

log.vals = data.frame(idr.mean = idr.mean.log, idr.val = idr.val.log, idr.max = idr.max.log)

long.log.vals = gather(log.vals, key="dataset")
head(long.log.vals)
ggplot(long.log.vals, aes(x=value, fill=dataset))  + geom_density(alpha=.5) + labs(title="Distributions of log10 transformed IDR values")

gr.promoters$IDR_logTEN_max = idr.max.log
gr.promoters$IDR_logTEN_mean = idr.mean.log
gr.promoters$IDR_logTEN_value = idr.val.log
sum(idr.mean.log > 2.5, na.rm=T)


```

```{r rob-combine}
datapath = normalizePath('../../../Rob/02_embryo_intestine_RNAseq/03_output/DE_Results_GFPplus-vs-GFPminus_apeglmShrink_220202.csv')
x = read.csv(datapath)
rownames(x) <- x$WBGeneID

# look at the number filtered by DESeq2
# as described by https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#pvaluesNA
baseMean_is_zero = x$baseMean == 0
pval_na = is.na(x$pvalue)
padj_na = is.na(x$padj)
# case one
sum(baseMean_is_zero & pval_na & padj_na)
# case two
sum(!baseMean_is_zero & pval_na & padj_na)
# case three
sum(!pval_na & padj_na)
head(x)

#x %>% filter(WBGeneID %in% gr.promoters$wbps_gene_id) -> x.coherent
mcols(gr.promoters) <- mcols(gr.promoters) %>% cbind(x[gr.promoters$wbps_gene_id,2:6])  %>% as.data.frame() %>% dplyr::rename(IDR_nlogq = nlogq)
head(gr.promoters)
names(gr.promoters) <- gr.promoters$wbps_gene_id

# sort promoters high to low by log2FC
gr.promoters = gr.promoters[order(gr.promoters$log2FoldChange,decreasing=T)]

# divide groups by peak and padj
enriched_intestine = gr.promoters$padj<.05 & !is.na(gr.promoters$padj)
has_peak = !is.nan(gr.promoters$IDR_max)
classA = enriched_intestine & has_peak
classB = !enriched_intestine & has_peak
classC = enriched_intestine & !has_peak
classD = !enriched_intestine & !has_peak


gr.promoters$class = "classA"
gr.promoters$class[classB] <- "classB"
gr.promoters$class[classC] <- "classC"
gr.promoters$class[classD] <- "classD"

promoters.hilo = as.data.frame(gr.promoters)

# BED format
write.table(promoters.hilo, file.path(OUTPUT_03, "promoters.hilo.bed"), quote=F, sep="\t", row.names=F, col.names=F)

# Matrix format readable into R
write.table(promoters.hilo, file.path(OUTPUT_03, "promoters.hilo.tsv"), quote=F, sep="\t", row.names=T, col.names=T)


write.table(promoters.hilo[classA,], 
            file.path(OUTPUT_03, "promoters.hilo.classA.bed"), quote=F, sep="\t", row.names=F, col.names=F)
write.table(promoters.hilo[classB,], 
            file.path(OUTPUT_03, "promoters.hilo.classB.bed"), quote=F, sep="\t", 
row.names=F, col.names=F)
write.table(promoters.hilo[classC,], 
            file.path(OUTPUT_03, "promoters.hilo.classC.bed"), quote=F, sep="\t", 
row.names=F, col.names=F)
write.table(promoters.hilo[classD,], 
            file.path(OUTPUT_03, "promoters.hilo.classD.bed"), quote=F, sep="\t", 
row.names=F, col.names=F)

# deeptooling up versus down only, no other filters
promoters.hilo.up = promoters.hilo %>% filter(log2FoldChange > 0)
promoters.hilo.down = promoters.hilo %>% filter(log2FoldChange < 0)

write.table(promoters.hilo.up, 
            file.path(OUTPUT_03, "promoters.hilo.up.bed"), 
            quote=F, 
            sep="\t", 
row.names=F, col.names=F)

write.table(promoters.hilo.down, 
            file.path(OUTPUT_03, "promoters.hilo.down.bed"), 
            quote=F, 
            sep="\t", 
row.names=F, col.names=F)

```

To produce the deeptools output, execute DEEPTOOLS.bash.

It will compute promoters.hilo.mx and promoters.hilo.pdf.

Deeptools PDFs indicate a font called dejavu, if you're tired of replacing it in Illustrator, install it from: https://sourceforge.net/projects/dejavu/


```{r gene-centric-to-appease-derptools, echo = FALSE, eval = FALSE}
# this code chunk is deactivated because the promoter-only visualization is better
classA.genes = promoters.hilo[classA]$wbps_gene_id
classB.genes = promoters.hilo[classB]$wbps_gene_id
classC.genes = promoters.hilo[classC]$wbps_gene_id
classD.genes = promoters.hilo[classD]$wbps_gene_id
genes = getCElegansGeneLocs(mart, gene_list=NULL, WBID=c(classA.genes,classB.genes,classC.genes,classD.genes))

names(genes) = genes$wbps_gene_id
gr.classA.genes = genes[classA.genes]
gr.classB.genes = genes[classB.genes]
gr.classC.genes = genes[classC.genes]
gr.classD.genes = genes[classD.genes]


write.table(as.data.frame(gr.classA.genes), 
            file.path(OUTPUT_03, "genes.classA.bed"), quote=F, sep="\t", row.names=F, col.names=F)
write.table(as.data.frame(gr.classB.genes), 
            file.path(OUTPUT_03, "genes.classB.bed"), quote=F, sep="\t", 
row.names=F, col.names=F)
write.table(as.data.frame(gr.classC.genes), 
            file.path(OUTPUT_03, "genes.classC.bed"), quote=F, sep="\t", 
row.names=F, col.names=F)
write.table(as.data.frame(gr.classD.genes), 
            file.path(OUTPUT_03, "genes.classD.bed"), quote=F, sep="\t", 
row.names=F, col.names=F)
```

```{r signal-vs-expression plots}
gr.promoters.classA = gr.promoters[classA]

# scatter plot with linear mods on logFC up and down separately
gr.promoters.classA %>% as.data.frame() %>% 
  ggplot(
    aes(x=log_chip_signal_max, 
        y=log2FoldChange,
        group=log2FoldChange>0)) + geom_point() +
        geom_smooth(method='lm', formula= y~x) +
        ggtitle("Peak + Intestine Enriched") 

classA.up = promoters.hilo %>% as.data.frame() %>% filter(classA & log2FoldChange > 0)
up.table = classA.up[,c('log2FoldChange',
                      'chip_signal_mean',
                      'chip_signal_max',
                      'log_chip_signal_mean', 
                      'log_chip_signal_max',  
                      'IDR_mean',   'IDR_max', 'IDR_value')]

cor.up.table = cor(up.table)
options(digits=3)
knitr::kable(cor.up.table, caption="Pairwise correlations")
```

```{r cor.tests}
cor.test(classA.up[,'log2FoldChange'],classA.up[,'IDR_mean'])
cor.test(classA.up[,'log2FoldChange'],classA.up[,'log_chip_signal_mean'])
```